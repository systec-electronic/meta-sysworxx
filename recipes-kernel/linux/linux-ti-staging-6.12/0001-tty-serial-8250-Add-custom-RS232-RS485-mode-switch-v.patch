From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Christian Schuster <christian.schuster@systec-electronic.com>
Date: Mon, 14 Oct 2024 13:28:49 +0200
Subject: [PATCH] tty: serial: 8250: Add custom RS232/RS485 mode switch via
 gpio

Signed-off-by: Andreas Dinter <andreas.dinter@systec-electronic.com>
Signed-off-by: Christian Schuster <christian.schuster@systec-electronic.com>
---
 drivers/tty/serial/8250/8250_omap.c | 36 ++++++++++++++++++++++++++++-
 1 file changed, 35 insertions(+), 1 deletion(-)

diff --git a/drivers/tty/serial/8250/8250_omap.c b/drivers/tty/serial/8250/8250_omap.c
index 110ff5926b02..b06c27929275 100644
--- a/drivers/tty/serial/8250/8250_omap.c
+++ b/drivers/tty/serial/8250/8250_omap.c
@@ -29,6 +29,7 @@
 #include <linux/sys_soc.h>
 #include <linux/reboot.h>
 #include <linux/pinctrl/consumer.h>
+#include <linux/gpio/consumer.h>
 
 #include "8250.h"
 
@@ -150,6 +151,10 @@ struct omap8250_priv {
 
 	struct pinctrl *pinctrl;
 	struct pinctrl_state *pinctrl_wakeup;
+
+	__u32 rs485_flags;
+	struct gpio_desc *sermode_gpio;
+	struct work_struct sermode_worker;
 };
 
 struct omap8250_dma_params {
@@ -1383,6 +1388,32 @@ static int omap8250_select_wakeup_pinctrl(struct device *dev,
 	return pinctrl_select_state(priv->pinctrl, priv->pinctrl_wakeup);
 }
 
+static int omap8250_em485_config(struct uart_port *port,
+				 struct ktermios *termios,
+				 struct serial_rs485 *rs485)
+{
+	struct uart_8250_port *up = up_to_u8250p(port);
+	struct omap8250_priv *priv = up->port.private_data;
+
+	int ret = omap8250_rs485_config(port, termios, rs485);
+	if ((ret == 0) && (priv->sermode_gpio)) {
+		priv->rs485_flags = rs485->flags;
+		schedule_work(&priv->sermode_worker);
+	}
+
+	return ret;
+}
+
+static void ti_sermode_worker(struct work_struct *work)
+{
+	struct omap8250_priv *priv = container_of(work, struct omap8250_priv, sermode_worker);
+
+	if (priv->rs485_flags & SER_RS485_ENABLED)
+		gpiod_set_value_cansleep(priv->sermode_gpio, 1);
+	else
+		gpiod_set_value_cansleep(priv->sermode_gpio, 0);
+}
+
 static struct omap8250_dma_params am654_dma = {
 	.rx_size = SZ_2K,
 	.rx_trigger = 1,
@@ -1482,7 +1513,7 @@ static int omap8250_probe(struct platform_device *pdev)
 	up.port.shutdown = omap_8250_shutdown;
 	up.port.throttle = omap_8250_throttle;
 	up.port.unthrottle = omap_8250_unthrottle;
-	up.port.rs485_config = omap8250_rs485_config;
+	up.port.rs485_config = omap8250_em485_config;
 	/* same rs485_supported for software emulation and native RS485 */
 	up.port.rs485_supported = serial8250_em485_supported;
 	up.rs485_start_tx = serial8250_em485_start_tx;
@@ -1612,6 +1643,9 @@ static int omap8250_probe(struct platform_device *pdev)
 	if (!IS_ERR_OR_NULL(priv->pinctrl))
 		priv->pinctrl_wakeup = pinctrl_lookup_state(priv->pinctrl, "wakeup");
 
+	priv->sermode_gpio = devm_gpiod_get_optional(&pdev->dev, "sermode", GPIOD_OUT_LOW);
+	INIT_WORK(&priv->sermode_worker, ti_sermode_worker);
+
 	return 0;
 err:
 	pm_runtime_dont_use_autosuspend(&pdev->dev);
-- 
2.52.0

