From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Andreas Dinter <andreas.dinter@systec-electronic.com>
Date: Wed, 18 Jun 2025 14:13:06 +0200
Subject: [PATCH] Port regdomain setting from summit-backports

Standard regulatory domain settings do not seem to work for BRCM4373
based devices. (at least with Ezurio firmware)

This patch ports the kernel module parameter. Changes are derived from
Ezurio backports release 12.103.0.5.

- https://github.com/Ezurio/SonaIF-Release-Packages/releases
- summit-backports-12.103.0.5.tar.bz2

Signed-off-by: Andreas Dinter <andreas.dinter@systec-electronic.com>
---
 .../broadcom/brcm80211/brcmfmac/cfg80211.c    | 57 +++++++++++++++++++
 .../broadcom/brcm80211/brcmfmac/common.c      |  7 +++
 .../broadcom/brcm80211/brcmfmac/common.h      |  2 +
 3 files changed, 66 insertions(+)

diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
index 349aa3439502..4e24b026f36d 100644
--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
@@ -8285,6 +8285,63 @@ struct brcmf_cfg80211_info *brcmf_cfg80211_attach(struct brcmf_pub *drvr,
 	ndev->ieee80211_ptr = &vif->wdev;
 	SET_NETDEV_DEV(ndev, wiphy_dev(cfg->wiphy));
 
+	if (strlen(drvr->settings->regdomain) != 0) {
+		struct brcmf_fil_country_le ccreq;
+
+		memset(&ccreq, 0, sizeof(ccreq));
+
+		// Convert ETSI pseudocode to underlying ccode (radio specific)
+		if (!strcmp("ETSI", drvr->settings->regdomain)) {
+			switch (drvr->bus_if->chip) {
+			case CY_CC_4373_CHIP_ID:
+			// case CY_CC_55572_CHIP_ID:
+				strcpy(ccreq.country_abbrev, "DE");
+				break;
+			case BRCM_CC_4339_CHIP_ID:
+			case BRCM_CC_43430_CHIP_ID:
+			case CY_CC_43439_CHIP_ID:
+				strcpy(ccreq.country_abbrev, "EU");
+				break;
+			}
+		} else {
+			memcpy(ccreq.country_abbrev, drvr->settings->regdomain, BRCMF_COUNTRY_BUF_SZ);
+		}
+
+		// Handle regrev for LWB5 for supported countries
+		if (drvr->bus_if->chip == BRCM_CC_4339_CHIP_ID) {
+			// country codes with rev (a country spec) need to also populate ccode parameter
+			memcpy(ccreq.ccode, ccreq.country_abbrev, BRCMF_COUNTRY_BUF_SZ);
+			if (!strcmp("US", ccreq.ccode))
+				ccreq.rev = cpu_to_le32(911);
+			else if (!strcmp("CA", ccreq.ccode))
+				ccreq.rev = cpu_to_le32(938);
+			else if (!strcmp("EU", ccreq.ccode))
+				ccreq.rev = cpu_to_le32(116);
+			else if (!strcmp("JP", ccreq.ccode))
+				ccreq.rev = cpu_to_le32(101);
+			else if (!strcmp("KR", ccreq.ccode))
+				ccreq.rev = cpu_to_le32(301);
+			else {
+				brcmf_err("Regulatory domain %s not supported, aborting!\n", drvr->settings->regdomain);
+				goto wiphy_out;
+			}
+		} else {
+			ccreq.rev = -1;
+		}
+
+		err = brcmf_fil_iovar_data_set(ifp, "country", &ccreq, sizeof(ccreq));
+		if (err) {
+			brcmf_err("Regulatory domain %s not supported, aborting!\n", drvr->settings->regdomain);
+			goto wiphy_out;
+		}
+		brcmf_info("Using regulatory domain %s\n", drvr->settings->regdomain);
+	} else if (drvr->bus_if->chip == CY_CC_4373_CHIP_ID
+			|| drvr->bus_if->chip == CY_CC_43439_CHIP_ID
+			/* || drvr->bus_if->chip == CY_CC_55572_CHIP_ID */) {
+		brcmf_err("Regulatory domain not configured, aborting!\n");
+		goto wiphy_out;
+	}
+
 	err = wl_init_priv(cfg);
 	if (err) {
 		bphy_err(drvr, "Failed to init iwm_priv (%d)\n", err);
diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/common.c b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/common.c
index b24faae35873..42435a7a951b 100644
--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/common.c
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/common.c
@@ -67,6 +67,11 @@ static int brcmf_iapp_enable;
 module_param_named(iapp, brcmf_iapp_enable, int, 0);
 MODULE_PARM_DESC(iapp, "Enable partial support for the obsoleted Inter-Access Point Protocol");
 
+static char brcmf_regdomain[BRCMF_REGDOMAIN_LEN];
+module_param_string(regdomain, brcmf_regdomain,
+		    BRCMF_REGDOMAIN_LEN, 0400);
+MODULE_PARM_DESC(regdomain, "Regulatory domain/country code");
+
 #ifdef DEBUG
 /* always succeed brcmf_bus_started() */
 static int brcmf_ignore_probe_fail;
@@ -537,6 +542,8 @@ struct brcmf_mp_device *brcmf_get_module_param(struct device *dev,
 	if (bus_type == BRCMF_BUSTYPE_SDIO)
 		settings->bus.sdio.txglomsz = brcmf_sdiod_txglomsz;
 
+	strncpy(settings->regdomain, brcmf_regdomain, BRCMF_REGDOMAIN_LEN);
+
 	/* See if there is any device specific platform data configured */
 	found = false;
 	if (brcmfmac_pdata) {
diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/common.h b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/common.h
index 2be2986d2110..85459e971287 100644
--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/common.h
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/common.h
@@ -10,6 +10,7 @@
 #include "fwil_types.h"
 
 #define BRCMF_FW_ALTPATH_LEN			256
+#define BRCMF_REGDOMAIN_LEN			10
 
 /* Definitions for the module global and device specific settings are defined
  * here. Two structs are used for them. brcmf_mp_global_t and brcmf_mp_device.
@@ -56,6 +57,7 @@ struct brcmf_mp_device {
 	const char	*antenna_sku;
 	const void	*cal_blob;
 	int		cal_size;
+	char		regdomain[BRCMF_REGDOMAIN_LEN];
 	union {
 		struct brcmfmac_sdio_pd sdio;
 	} bus;
-- 
2.49.0

